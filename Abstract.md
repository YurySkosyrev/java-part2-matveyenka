# Курс по Java. Part 2 #
## ООП ##

В Java никакой класс не должен лежать в root-директории src. Нужно создавать пакеты.

**Live-template** - пишем ключевое слово и нажимаем Tab (или Enter). Idea сама генерирует нужный код.</br>
Пример: iter - цикл for-each. main, sout e.t.c

**Структурное программирование** - последовательное выполнение кода, строчка за строчкой.

**ООП** - стиль программирования, в котором операции производятся над объектами, используется их функционал и изменяется их состояние.

**Объект** - конкретный экземпляр кого-либо класса.

Классы согласно конвенции именуются с большой буквы в camel-case, методы с маленькой буквы.</br> Исключение - конструктор, его имя должно совпадать с именем класса и начинаться с большой буквы.

**Ctrl + D** - продублировать выделенный код.

В сигнатуру метода входит название функции и аргументы. Возвращаемый тип не входит в сигнатуру метода, он не учитывается при перегрузке.

**Ctrl + P** - показывает все возможные перегрузки метода.

Модификаторы доступа ставятся над классами, полями, методами.

**private** - поля и методы доступны только внутри класса.

**protected** - похож на package-private, только ещё доступ предоставляется в классах-наследниках.

**package private** (нет модификатора) - доступ только внутри пакета.

**public** - виден отовсюду

Для классов, кроме внутренних вложенных можно указывать либо public, либо ничего.

Пакет - неотъемлимая часть имени класса.

Пакет java.lang импортится автоматически.

## Heap and Stack

В начале работы Java-приложения ему выделяется некоторое колличество оперативной памяти, необходимой для работы. Размер памяти определяется через параметры командной строки или дефолтным значением.

Память, которая выделяется под Java-процесс разбивается на два блока: **Heap**(больший) и **Stack**.

Heap - общий для всех потоков, а Stack создаётся для каждого потока свой.

В многопоточности возникают коллизии, когда из разных **Stackов** происходит доступ к одному и тому же объекту в **Heap**.

Правила:
1. Во время выполнение программ все локальные переменные примитивного типа (и их значения) полностью находятся в стековой области памяти. 
2. Ключевое слово new означает выделение памяти под объект в **Heap**. В **Stack** хранится ссылка на эту область памяти.

В Java по умолчанию под ссылки выделяется 4 байта. Размер зависит от размера **Heap**, если он больше 32 ГБ, то на ссылку выделяется 8 байт, чтобы покрыть адресное пространство.

У каждого объекта есть ссылка this, которая указывает на этот объект, для удобства.

После выполнения потока все ссылки на объекты в Heap удаляются. И необходимо собрать мусор с помощью Garbage Collector. В Heap есть разные области памяти, чтобы разделять новые и старые объекты и запускать разные механизмы для очистки Heap.

Ctrl + Alt + M - участок кода переносится в отдельный метод.

По статистике строки занимают до 70% объема Heap, поэтому придуманы различные методы обратки строк. 
Например, кэширование, то есть, если строка есть в Heap, её переиспользуют, а не создают объект заново.

Модификатор static указывает, что поле или метод относится ко всему классу, а не к конкретному экземпляру и может быть вызван по имени класса.
Вызвать через ключевое слово this значение этого поля нельзя.

Метод getClass возвращает класс, к которому принадлежит объект.
Class<? extends Computer> clazz = computer.getClass();

класс Class необходим, чтобы инициализировать классы, которые мы создаём. На каждый класс, который мы создали создаётся объект, который сохраняется в MetaSpace - область памяти в Heap для хранения классов.

Static используется для утилитных классов, для которых не нужен конретный экземпляр.

Константы в классах принято создавать статическими.

prsf - создание private static final.

Согласно конвенции все константы должны именоваться в upper-case и snake-case.

## Класс String

В классе String главное поле - byte[] value. В более ранних версиях было char[]. Замена связана с более оптимальным использованием памяти, большинство строк представляют собой массивы латинских символов, один символ занимает 1 байт, а char занимает 2 байта.

По умолчанию Charset - utf-8. Можно передавать Charset в конструктор String.

Строки сравниваются методом compareTo.

lines() - возвращает стрим из строки.

Из static функции мы можем вызывать только static функции, либо статеческие методы у классов.

Ctrl + Alt + V - создание переменной.

Ctrl + Alt + N - убрать локальную переменную (inline).

Все методы класса String создают новую строку, так как объекты класса String immutable.

System - утилитный метод. Содержит только private конструктор, т.е. экземпляр этого класса можно создать только из него самого.

Для конкатенации строк в цикле необходимо использовать StringBuilder. При обычной конкатенации строк каждый раз создаётся новый объект.
В классе StringBuilder так же есть массив char[] value, но ещё и счётчик count, который показывает на сколько заполнен массив.
StringBuilder работает похожим образом на ArrayList. Таким образом новый объект создаётся тольк тогда когда заканчивается capacity массива value.

StringBuffer - потокобезопасный класс, то есть все его методы синхронизированы (помечены ключевым словом synchronized - то есть эту функцию у одного и того же объекта может вызвать только один поток одновременно)

Однако часто используется и StringBuilder т.к. мы создаём локальную переменную этого типа, которая потокобезопасна. Потому что каждый поток создаёт свою локальную переменную и только у него есть доступ к ссылке на эту переменную.

## Принципы ООП

Инкупсуляция - скрытие сложности(поля) от пользователя.
public-методы называют интерфейсами.

extends - ключевое слово наследования. При наследовании мы обязаны вызвать в конструкторе, один из конструкторов родителя (super()).
super() вызывается в первой строчке.
Если в классе есть конструктор без параметров, то super() можно опустить.

В Java нет множественного наследования.

В Java все классы наследуются от класса Object.

Ctrl + F12 - отображение всех методов класса.

Через ключевое слово this() можно вызвать конструктор данного класса.

native - ключевое слово, означающее, что данный метод использует нативные библиотеки (напианные на С, С++) для улучшения производительности.

В каждом классе можно указать блок инициализации (используется редко), он выполняется перед конструктором:
 {
    System.out.println("init")
 }

Статический блок инициализации вызывется один раз при создании первого объекта класса, т.е. когда создаётся объект класса Class
 static {
    System.out.println("init")
 }


## Абстрактные классы

+ Запрещается создавать экземпляры класса.
+ Класс создан только для его наследования.

Чтобы сделать класс абстрактным его нужно пометить ключевым словом abstract.

Абстрактный метод - метод, который должен быть переопределен во всех классах наследниках.

Ex. public abstract void load();

Если другой абстрактный класс наследует абстрактный, то нет обязательства реализовывать абстрактный метод.

Мы не можем создать абстрактный метод у неабстрактного класса.

Чтобы запретить наследование от данного класса нужно использовать ключевое слово final. Нельзя одновременно ипользовать ключевые слова final и abstract.

Полиморфизм - один интерфейс и множество реализаций.
Под интерфейсом понимается открытый функционал класса.

Переопределить можно не только абстрактные методы, главное, чтобы они не были private.

Мы не можем сужать область видимости базового функционала.

instanseof - действительно ли ссылка ведёт на объект указанного типа.

Если пометить метод ключевым словом final его нельзя будет переопределить в классах-наследниках.

static методы нельзя переопределить, потому что они относятся не к объекту, а к классу.

Интерфейсы нужны для того, чтобы привнести какой-то функционал в наш класс.
В интерфейсах в отличии от абстрактных классов нельзя создавать никакие поля, кроме констант.
В интерфейсах все методы по умолчанию public abstract.
Интерфейсы так же можно наследовать ключевым словом extends, только в отличии от классов допустимо множественное наследование т.к. это наследование интерфейсов.

Ключевое слово default введно начиная с Java 8. В Java 8 появились stream в коллекциях и было необходимо привнести новый функционал в существующую иерархию коллекций, но без её расширения и введения новых классов. Дефолтные методы не зависят от состояния, а зависят от функционала.

default методы используются тогда, когда реализация какого-то метода во всех классах одинакова. Такие методы реализуются прямо внутри интерфейса.

Так же в Java 8 стало возможным создавать private методы в интерфейсах. Такие методы можно было бы создавать static, но тогда к ним будет доступ и вне, а так как это скрытая реализация их сделали private.

Во вложенных классах помимо модификаторов public и package private допустимо использовать private.

Вложенные классы могут быть static, но тогда у них теряется доступ к методам внешнего класса, к полям, доступ остаётся.

Локальный класс описывается и объявляется внутри метода.

Enum - нужен когда необходимо ограничить число наследников класса.
Константы в enum пишутся в Snake Upper case, по сути это обычные классы.
Доступны методы values(), ordinal() и так далее.
Java автоматически создает singltone констант в enum.
Нельзя наследоваться или наследовать enum.
Но доступна реализация интерфейсов (в том числе абстрактных). Переопределение абстрактных методов происходит прямо в блоке кода после каждого из перечислений. Так же можно и переопределить методы интерфейса либо для каждого класса, либо для всего enum в отдельном методе.

## Generics

Generics - обобщенные типы.

В Java запрещено создавать массивы параметризованного типа, т.к. неизвестно, сколько выделить под него памяти.

При объявлении класса, даже если он параметризован, Java допускает не указвать тип класса для совместимости с предыдущими версиями. При этом класс параметризуется типом Object.

Generics нужны для безопасной работы с типами объектов.

Есть два уровня параметризации - на уровне класса и на уровне метода.

public abstract class Hero\<T> {...}

public class Archer\<T> extends Hero\<T> {...}

Параметризацию так же можно ограничивать: 

public interface Weapon {...}<br>
public interface RangeWeapon extends Weapon {...}<br>
public class Bow inplements RangeWeapon {...}

public abstract class Hero\<T extends Weapon> {...}

public class Archer\<T extends RangeWeapon> extends Hero\<T> {...}
Archer\<Bow> archer = new Archer<>();

каждый класс может быть параметризован несколькими типами

Параметризация на уровне метода:
public static \<T extends Weapon> void printWeaponDamage(Hero\<T> hero) {...}

Можно использовать wildcard:
public static void printWeaponDamage(Hero\<? extends Weapon> hero) {...}

Можно ограничивать наследование снизу т.е. для всех предшественников:
public static void printWeaponDamage(Hero\<? super Weapon> hero) {...}

Ограничения сверху и снизу используются для 
* Producer - extends
* Consumer - super

## Коллекции

Коллекция - структура данных, набор элементов одного и того же типа.

interface Collection/<E> extends Iterable/<E>- базовый интерфейс, все коллекции реализуют этот интерфейс.

Итератор - шаблон проектирования, который позволяет нам итерировать по всем элементам коллекции.

Коллекции нельзя параметризовать примитивным типом, именно для этого существуют классы обёртки.

Основные интерфейсы коллекций:
* List
* Set
* Queue

Map не является коллекцией, но содержит коллекцию

## Big O Notation

O(1) - получить элемент по индексу из массива

O(log2 n) - бинарный поиск

O(n) - вставка в массив

O(n logn) - хорошая сортировка

O(n^2) - сортировка пузырьком

O(2^n) - 

O(n!) - самая плохая 

При создании массива с помощью слова new мы получаем ссылку на первый элемент массива в Heap. Чтобы получить элемент по индексу (например, если элементы типа int) нужно взять адрес первого элемента и сместить его на 4 * i байт.

Big O Notation используется не только для оценки скорости выполнения алгоритма, но и для оценки выделения объёма памяти. 

## ArrayList

List.of() - создание неизменяемого списка на основе элементов.

transient Odject[] elementData - главное поле класса ArrayList. По сути ArrayList - список в основании которого обычный массив.

Если колличество элементов превышает capaсity, то массив автоматически расширяется, новая capacity считается по определенному алгоритму в методе grow(). Создаётся новый массив с новым размером, в который копируется старый.

При инициализации ArrayList создаётся elementData с дефолтным значением (пустым) DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} по сути это заглушка.

Сложность:
Добавление элемента (по скорости) - O(1)
Добавление элемента (по памяти) - O(n)
Получение элемента по индексу - O(1)
Получение элемента по значению - O(n)

## LinkedList

Реализация интерфейса List не основывающаяся на массиве.

LinkedList хранит указатели на первый и последний элемент типа Node<E>, а так же колличество элементов.
Node<E> оболочка над значением Е, которая хранит ссылка на предыдущий и следующий узел.

Хранение не только элементов, но и ссылок на другие элементы означает, что памяти требуется больше чем у ArrayList.

LinkedList реализует интерфейс Deque.

Сложность:
Добавление элемента (по скорости) - O(n)
Добавление элемента (по памяти) - O(1)
Получение элемента по индексу - O(n)
Получение элемента по значению - O(n)

При поиске по индексу есть определенная оптимизация - определяется откуда ближе идти, с конца или с начала.

Если много вставок и удаление в середину, то есть определённая выгода LinkedList.

## Iterator

Два основных метода hasNext() и next(). Перед вызовом next() нужно вызывать hasNext().

Через цикл foreach удалить элементы не получится, foreach только на чтение.

## Equals and HashCode

Все объекты наследуются от Object, поэтому им доступны методы equals() и hashCode(). hashCode() написан на языке C (помечен native), он генерирует некое число int на основании области памяти, выделенной для нашего объекта.

Методы equals() и hashCode() необходимо переопределять одновременно.

Контракты метода equals():

1. Рефлексивность. Объект должен быть равен самому себе, т.е. для каждого ненулевого х, x.equals(x) должно возвращать true.

2. Симметричность. Объекты должны быть равны друг другу, т.е. для ненулевых х и y x.equals(y) должно возвращать true только если y.equals(x) возвращает true

3. Транзитивность. Для ненулевых x, y, z если x.equals(y) == true, y.equals(z) == true => x.equals(z) == true.

4. Повторяемость. Для ненулевых x и y последовательные вызовы x.equals(y) должны постоянно возвращать true или постоянно возвращать false, при условии, что x и y не меняются.

Особенности HashCode()

1. У двух одинаковых обектов ДОЛЖЕН быть одинаковых хеш-код

2. У двух разных объектов МОЖЕТ быть одинаковый хеш-код. Это называется коллизией. Особенность хорошо написанной функции hashCode() - минимум коллизий.

3. Нельзя возвращать константу или рандомное число.

Object - утилитный класс, появился после Java 1.7, содержит методы для работы с классами.

## HashMap

Ассоциативный массив содержит в себе два generic типа - ключ и значение.

Главное требование - уникальность ключа.

Ассоциативный массив в Java представлен реализациями интерфейса Map<K, V>
HashMap() - Map на основе hash-таблиц.

Map не является коллекцией, но содержит в себе две коллекции:
* keySet(): Set<K>
* values(): Collection<V>

Основное поле Map - transient Node<K,V>[] table
Node состоит из полей
final int hash - хеш-код ключа, подсчитывается один раз и сохраняется
final K key - ключ
V value - значение
Node<K,V> next - ссылка для решения коллизий.

Все размеры ассоциативных таблиц кратны 2 в некоторой степени.
Начальный размер массива - 16.

При помещении объекта в HashMap на основании ключа вычисляется его хеш-код. Берём остаток от деления на количество элементов в массиве Map (бакетов) и определяем ячеку, в которую необходимо поместить новый объект типа Node<K,V>.

В случае, если хеш-код у нового объекта совпадает с ранее записанным, то всё равно создаётся объект Node<K,V>, на который будет ссылаться ссылкасNode<K,V> next последнего объека в листе в бакете.

Начиная с Java 1.8 если в одной ячейки становится много (больше 8), то связанный список преобразуется в дерево.
Сложно итерации по списку O(n) по дереву O(logN), что лучше.

При получении элемента по ключу, если попадём в бакет с несколькими элементами, то будем итерировать по списку и сравнивать ключи. Т.к. главное условие Map - уникальность ключа, то будет найдет только один объект. 
А при добавлении объекта с таким же ключем, предыдущее значение будет перезаписано

Преимущество HashMap в том, что доступ к элементу осуществляется за время O(1).

Node<K, V> реализует интерфейс EntrySet<K, V>

putIfAbcent - добавить в Map только в том случае, если такого ключа не существует.

Расширение массива происходит, когда достиается loadfactor.
Т.е. процент заполненности.

## LinkedHashMap

При добавлении элементов в HashMap порядок добавления элементов нарушается потому, что порядок зависит от хеш-кода ключа.

Чтобы сохранить порядок используем LinkedHashMap.

LinkedHashMap - это обычный HashMap, который хранит в классе Entry<K, V> extends Node<K, V> ссылки на предыдущий и последующий элемент.

## Сортировка коллекций

Метод Array.asList возвращает изменяемую коллекцию.

Чтобы сравнивать объекты необходимо, что бы они реализовывали интерфейс Comparable/<T>, который состоит из одного метода compareTo. Сортируте только в одном порядке.

Тогда с помощью метода Collections.sort(list) можно отсортировать коллекцию.

Так же есть вариант реализовать интерфейс Comparator/<T> и его метод compare(o1:T, o2:T):int.

Позже у класса List появился метод sort, который также принимает компаратор.
myList.sort(new myComparator())

Начиная с Java 1.8 появилась ещё более короткая запись:
myList.sort(Comparator.comparing(Person::getFirstName)).thenComparing(Person::getLastName)

## TreeMap

TreeMap хранит элементы в определенном порядке (в отсортированном виде).
TreeMap может принимать Comparator.

TreeMap основана на красно-черных деревьях.
Сложность поиска и вставки элемента O(logN).

Если постоянно добавлять в одну половину дерева, оно может превратиться в связный список.
Поэтому в TreeMap есть булева переменная, которая зависит от нескольких условий и показывает, когда нужно балансировать дерево.

## Set

Метод add() возвращает boolean - удалось ли добавить или нет.

HashSet не сохраняет порядок при добавлении.
LinkedHashSet сохранят порядок при добавлении.
TreeSet сортирует при добавлении.

Соответствующая реализация Set основана на соответствующей реализации Map, при этом операции производятся только с ключами, а в значение всегда записывается один и тот же Dummy-объект PRESENT.

у Set нет метода sort. Для сортировки нужно использовать TreeSet.

## Другие коллекции

IdentityHashMap - ключи сравниваются по ссылкам, а не по значениям. Нет надобности переопределять equals(). При этом ускоряется процесс генерации hash-кода и сравнение объектов.

WeakHashMap - объекты в ассоциативном массиве хранятся не постоянно, а переодически исчезают. Нужна для хранение кэша.

Hashtable - лучше не использовать. Предшественник HashMap. Старые коллекции хороши тем, что все их методы синхронизированы, это означает что этот метод может быть вызыван только из одного потока в один момент времени. 
Начиная с Java 1.5 появился пакет Java.Util.Cuncurrent, лучше использовать его для потокобезопасности - ConcurrentMap.

Vector - предшественник ArrayList.

Stack - вместо него лучше использовать любую реализацию интерфейса Deque - LinkedList, ArrayDeque (коллекция основана на обычном массиве). 

## Коллекции практика.

Arrays.ofList возвращает неизменяемую коллекцию, remove не поддерживается.
Arrays.asList возвращает так же неизменяему коллекцию, но в ней можно переставлять элементы.
Цикл forEach только для чтения. Во время цикла нельзя удалять элементы.

Параметры, которые передаются в метод лучше не менять, нужно создавать новый объект внутри метода и производить с ним действия.

Заполнить Map можно с помощью метода Map.of(K, V)

Начиная с Java 1.8 у Map есть метод merge, которой по ключу и значению выполняет операцию слияние.

Comparator.reverseOrder() - обратный порядок.

## Исключения

Throwable - базовый класс исключений.

Ctrl + Alt + H - открыть иерархию класса.

Throwable:
* Error - ошибки, с которыми ничего нельзя сделать. OutOfMemory - закончилось место в Heap, StackOverFlow - закончилось место в стековой области памяти.

* Exception - можем обработать.
   * Runtime
   * Все остальные

Исключения обрабатываются: 
* в месте, где их бросили : throw new FileNotFoundException()
* либо пробрасываются в метод выше : <br>public static void errMethod() throws FileNotFoundException.

Сообщения об ошибках выводятся в консоль объектом **err**, поэтому при выводе в консоль объектом **out** может возникнуть конфликтная ситуация.

В блоке catch можно обработать несколько исключений с помощью бинарного оператора или |. 

Можно указать общего предка для обработки разных исключений.

При использовании нескольких блоков catch важно учитывать иерархию исключений в этих блоках.

В блоке finally обычно очищаются ресурсы.

finally имеет более высокий приоритет, чем return, если return был вызван в блоке try.

Мы не обязаны остлеживать Runtime исключения т.е. писать try-catch блоки или пробрасывать их дальше с помощью throws. Пробрасывыние происходит автоматически.

RunTimeExceptions можно обрабатывать так же как и неRunTime.
Пример RuntimeException - выход за границы массива, деление на ноль и т.д.

При создании своих Exceptions предпочтительнее наследовать их от RuntimeExceptions

prsf + tab - private static final myVar.

## Функциональное программирование

Функциональный интерфейс содержит единственный метод не default и не private, для реализации.
@FunctionalInterface - предохраняет от объявления второго метода, не default и не private.

Функциональные интерфейсы позволяют использовать лямбда (стрелочные) функции.

Лямбда выражения можно заменить ещё более лаконичной записью с ссылкой на метод Integer::compare.

Функциональные интерфейсы:

public interface Function<T, R>{
   R apply(T t);
}

public interface Predicate<T>{
   boolean test(T t);
}

public interface Consumer<T>{
   void accept(T t);
}

public interface Supplier<T>{
   T get();
}

Ещё BiFunction, BiConsumer.

## Stream

В Java 1.8 появились Stream. Для их введения были так же добавлены default методы в интерфейсах. default метод позволяет не переопределять одинаковым образом у всех коллекций метод stream() интерфейса Collection.

Существуют три отдельных стрима для примитивных типов: IntStream, LongStream, DoubleStream.

peek - нетерминальный метод, forEach - терминальный.

IntStream.range(0,10) - создать стрим в диапазоне от 0 до 10
IntStream.iterate(0, func) - бесконечный стрим.

MapReduce - программная модель, которая позволяет преобразовать данные при необходимости их последующей обработки. Обработка происходит параллельно.

Stream.of(...)
   .parallel()
   .map(Student::getAge)
   .reduce(Math::max)
   .ifPresent(System.out::println)

.sequence - обработка в одном потоке.

## Optional

BinaryOperator /<T, T, T> в отличии от BinaryFunction /<T,V,R> принимает один тип переменной.

Optional - обычная обертка вокруг значения.

Optional всегда работает с одним единственным элементом, в отличии от Stream.

orElse() - всегда создаётся значение и выделяется память под значение по умолчанию (если отсутствует значение в Optional)
orElseGet() - Lazy версия orElse()

flatMap() - приходит Optional и возвращает Optional

Fail-fast метод. Исключение бросается в непосредственном месте появления исключительной ситуации, а не в последующих
методах. Исключительная ситуация находится как можно раньше.

Из методов не принято возвращать null, а Optional.

Optional - nullsafe, isPresent - тоже.

flatmap у Stream возвращает Stream от каждого элемента. Может быть удобно, если у каждого объекта в Stream есть поле типа List.
у Optional нет peek.

Сложность метода sort() у Stream - O(NlogN)
max() - O(N)

Вместо person -> person можно использовать Function.identity().

## Потоки ввода-вывода.

InputStream - поток байтов из источника информации в наше приложение. OutputStream - обратный процесс.

Файлы в Java представляются классом File из Java.io.
File file = new File("test/1") - логическое представление. Сам фаил - физическое представление.

Класс InputStream реализует интерфейс Closeable с одним методом close(). Т.е. потоки мы должны закрывать после использования,
чтобы не было утечек памяти. Так же есть ограничения по колличеству потоков к одному файлу.

Интерфейс Closeable расширяет интерфейс AutoСloseable, который появился в Java 1.7 для использования в 
try с ресурсами, чтобы потоки закрывались сами автоматически.

Методы InputStream:

available() - сколько байт ещё не считано из потока.
read() - много разных перегруженных методов для считывания байтов (по одному, диапазон, массив и т.д.)

Наследники InputStream:

ObjectInputStream - считывание Java-объектов из файла. Часто используется для сериализации и десериализации.
ByteArrayInputStream - работа с потоком байт.
FileInputStream - для работы с файлами на жестком диске.
FilterInputStream - часто для работы с потоками применяют паттерн декоратор, например для создания буффера при считывании
информации. Чаще всего используется BufferedInputStream(InputStream).

Для безопасного формирования пути к файлу, лучше использовать специальную платформозависимую константу File.separetor.
File.pathseparator - разделитель для environment variables.

Начиная с Java 1.7 появился класс Path из библиотеки Java.nio - неблокирующий ввод вывод.
Path.of(перечисление папок и файла в пути) - создание переменной типа Path.
.toFile - преобразовать в объект типа File.

Класс Reader предназначен для работы с текстовой информацией, а InputStream - с потоком байт.
Наследники класса Reader:
InputStreamReader
BufferReader
CharArrayReader

Для работы со строками удобно использовать декоратор BufferReader над классом FileReader - наследник InputStreamReader

метод flush() нужен при записи в файл с использованием буффера, чтобы в самый последний момент мы не забыли передать буфферезированную информацию. 

System.lineSeparator() - разделитель строк для используемой среды.

Наследники класса Writer:
PrintWriter
BufferedWriter
OutputStreamWriter(FileWriter)

При работе с строками нужно не забывать про кодировку.

BufferedWriter - оболочка FIleWriter (или вообще любой Writer)

## Класс Files
Утилитный класс, появился в Java 1.7, для упрощения работы с потоками ввода-вывода, и уходом от вложенных конструкций.

Если класс имеет private конструктор, то нельзя создать экземпляр этого класса.

Класс Files работает с классом Path, позволяет создавать папки и файлы, копировать, записывать, читать информацию, создавать временные файлы, проверять права доступа.

walk() - итерирование по всему дереву каталога.

Класс Scanner не наследуюется от Reader или InputStream, но так же является удобным для работы потоками. Наследуется от класса Iterator.

В блок try можно помещать объекты реализующие интерфейс AutoCloseable.

File.lines() возвращает стрим, этот метод необходимо оборачивать в try, он более эффективен, чем File.readAllLines, так как нет необходимости держать в памяти весь файл.

В lambda-выражении нельзя пробросить исключение дальше, его нужно обрабатывать на месте.

## Сериализация и десериализация

Сериализация - представление объекта в виде потока байт, десериализация - наоборот.

Для того, чтобы объект можно было сериализовать, он должен реализовывать интерфейся Serializable.

Интерфейс, в котором нет методов, называется маркером. Показывает наличие у класса какого-либо свойства.

При сериализации через reflection api мы получаем доступ к значениям полей объекта и сохраняем их на диск без использования геттеров.

Сериализацию и десериализацию можно осуществить с помощью методов ObjectInputStream и ObjectOutputStream.

Если в приложении в которое передается десериализуемый объект не найдётся подходящего класса - возникнет ClassNotFoundException.

Десериализация происходит так же с использованием reflection api без использования констуктора и сеттеров.

Есть много тонкостей с наследованием. При наследовании могут поля у базовых классов, но мы не сможем их заполнить, поэтому обязательно нужен конструктор без параметров.

При сериализации генерируется ID который показывает, какая была версия класса. При последуюей десериализации версии должны совпасть, иначе будет выброшен Exception. 
Чтобы этого избежать можно в классе создать private static final long serialVersionUID.

При сериализации static поля не записываются, так как они принадлежат всему классу. Кроме serialVersionUID.

Ключевое слово transient - не хотим, чтобы поле сериализовалось.

Для классов можно переопределять методы readObject, writeOblect.
readResolve - подмена прочитанного объекта на другой. Делается для синглтонов - классов, содержащих один единственный объект (enum).

## Date and Time API

API - Application programm interface.
В данном случае есть класс и набор методов, который мы можем использовать.
Date, Time обновленные появились в Java 8.

Unix-time - система описания моментов во времени определяется как колличество миллисекунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года.
UTC - всемирное время.

java.time.ZonedDateTime (заменил java.util.Calendar) - самый мощный класс с полной информацией о временном контексте.

java.time.Instant (заменил java.util.Date) - представляет точку на временной шкале (не хранит зону)

java.time.LocalDate (заменил java.sql.Date) - представление только даты без времени и зоны.

java.time.LocalTime (заменил java.sql.Time) - представление только времени без даты и зоны.

java.time.LocalDateTime (заменил java.sql.timestamp) - представление и даты и времени без зоны.

java.time.OffsetTime - представление только времени и зоны.

java.time.OffsetDateTime - представление даты, времени и зоны.

java.time.Period - описание календарной длительности (периода) в виде кортежа (год, месяц, день).

java.time.Duration - описание точной длительности в виде целого количества секунд и долей текущей секунды в виде наносекунд.

java.time.DataTimeFormatter - класс определяет настройки форматирования и парсинг.

Почти во всех классах старого Date/Time API появились методы для преобразования в классы нового Date/Time API (но не наоборот).

Все классы нового Date/Time API, в отличии от старого, immutable.

ChronoUnit.DAYS.between(Temporal t1, Temporal t2) - получить количество дней между двумя датами.

## Многопоточность

Java поддерживает возможность одновременной обработки множества запросов.

Каждый поток имеет своё название и стековую область памяти.

Thread.currentThread() - получить текущий поток.

Способы создания потоков:

* унаследовать класс Thread
* реализовать интерфейс Runnable.

**1. Наследование от Thread.**

**public class MyThread extends Thread {...}**

 Кроме того нужно переопределить метод **run()**.

Для запуска экземпляра класса MyThread в методе main другого класса (в другом потоке), необходимо вызвать метод **start()**.

Если мы хотим, чтобы поток, в котором был создан другой поток, ожидал окончания его выполнения прежде, чем продолжить своё выполнение, мы должны вызвать метод **join()**. При этом может возникнуть **InterruptedException**.

После того, как поток начал выполнение, его невозможно остановить.

При вызове метода **interrupt()** возможны два варианта:

* Если объект находился в этот момент в состоянии ожидания, например, join или sleep, ожидание будет прервано и программа выбросит **InterruptedException**.
* Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг **interrupted**.  

Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно. Для этого в классе Thread есть специальный метод - boolean isInterrupted().

**2. Реализация функционального интерфейса Runnable.**

Необходимо реализовать метод run(), но при этом нет никаких наследуемых методов класса Thread.

Чтобы запустить созданный поток в другом потоке необходимо создать экземпляр класса Thread, при помощи конструктора с параметром Runnable target.

***Thread runnbleThread = new Thread(new MyRunnable())***

Так как Runnable функциональный интерфейс, то поток можно создать через лямбда-выражение:

***Thread lambdaThread = new Thread(() -> ...)***

При запуске нескольких потоков порядок не гарантирован.

При наследовании от интерфейса **Runnable** появляется возможность наследоваться от какого-то класса, в отличии от варианта при наследовании от **Thread**. Но при этом в классе-потоке нет никаких методов от класса **Thread**. Их можно вызвать через **Thread.curentThread.method()**.

## Состояние потоков

У каждого потока есть определенное состояние в каждый момент времени.

**getState() -> enum State** - получение состояния

* NEW - ещё не запущен
* RUNNABLE - запущен
* BLOCKED - блокирован другим потоком
* WAITING - ожидает (join(), sleep())
* TAIMED_WAITING - ожидает определенное время. В join() можно передавать миллисекунды.
* TERMINATED - завершён.

Завершённый поток нельзя запустить вновь. Его можно только создать заново. Раньше был deprecated метод stop(). Сейчас он запрещён, так как в останавливаемом потоке могут быть открытые ресурсы, что приводит к их блокированию или утечке памяти.

## Атомарные операции

Одна из проблем многопоточности в том, что баги сложно воспроизводить при тестировании.

Для процессора операции бывают атомарными и составными:

count++

* считывание
* изменение
* запись

Если переменная count распределена между несколькими потоками, то может возникнуть ситуация, когда два потока считают одновременно одно и то же значение. Сделают инкремент и запишут обратно. При этом часть операций инкремента будет утеряно.

Для решения проблемы можно использовать ключевое слово **synchronized**, либо **объекты-atomic**, которые появились с Java 1.5 в пакете Java.util.cuncurent

## Ключевое слово Synchronized

**synchronized** можно использовать:

* на уровне метода <br> 
```java
public synchronized void increment()
```

В один и тот же момент времени только один поток у одного и того же объекта может вызвать этот метод

* на уровне блока <br>
```java
synchronized(this) { count++; }
````
То же только для кода внутри блока

Монитор - средство обеспечения контроля за доступом к ресурсу. У каждого объекта есть свой монитор. Булево значение.

При synchronized блока указывается у какого объекта необходимо захватить монитор.

При захвате монитора объекта мы можем выполнять все его **synchronized** методы. Другие потоки не могут выполнять методы, пока монитор не освободится и находятся в состоянии **BLOCKED**.

Таким образом любой метод можно сделать атомарным.

**synchronized** на уровне метода самодокументирован.

**synchronized(this)** более гибкий, можно синхронизировать только часть кода, но тогда может быть неясно, что весь метод синхронизирован, нужно читать документацию к методу.

При синхронизации статических полей и методов захватывается монитор объекта класса class:

```java
synchronized(Counter.class){...}
```

## Синхронизированные коллекции

При попытке вставки в один ArrayList из разных потоков может возникнуть проблема синхронизации.

Процессор кэширует elementData или size у ArrayList. При этом один процессор не может увидеть изменения в кэше другого. Т.е. изменение ссылки elementData может не отобразиться в другом потоке, либо отобразиться с течением времени.
	
Подобный подход:
```java
	public class ListThread extends Thread {
	   private final List <Integer> list {
	      synchronized(list) { add() }
	   }
	}
```

не решает проблему т.к. сам метод add не синхронизирован.

Решение - использовать синхронизированные коллекции из класса Collections.synchronizedList(List \<T> list)

В этом классе выделяется поле под сам List и специальный объект mutex по которому происходит синхронизация.

Часто выделяют отдельный объект для захвата монитора, вместо использования коллекции. Это нужно для разделения обязанностей.

Захват монитора является трудозатратной операцией. SunchronizedList нужно использовать только в крайних случаях.

Начиная с Java 1.5 появляется java.util.Cuncurrent - его и нужно использовать.

## Ключевое слово volatile.

Пример. 

```java
Thread thread1 = new Thread(() -> {
   if (!flag) {
      System.out.println("still false");
   }
}); 
thread1.start();

Thread.sleep(5L);

Thread thread2 = new (() -> {
   flag = true;
   System.out.println("flag set true");
});
thread2.start();
```

Может возникнуть ситуация, что изменения flag во втором потоке, не увидит первый поток.

Это возникает от того, что каждый поток будет запущен на своём процессоре, который запишет flag в свой кэш, чтобы не обращаться постоянно в RAM. <br>
Каждое ядро процессора содержит свой кэш, причем несколько уровней.

Таким образом thread2 может не сразу изменить значение flag в RAM, хотя в его кэше оно изменилось. А thread1 может не сразу обновить значение flag в своём кэше, хотя изменилось в RAM.

Чтобы не допускать этой проблемы можно использовать слово **volatile** - оно означает, что для данной переменной не нужно использовать оптимизации: кэш процессора или менять код на уровне JVM.

**volatile** работает для примитивов и ссылок. Содержимое по ссылке не гарантировано.<br>
При одном ядре всё равно нужно использовать **volatile** так как существуют оптимизации JVM.

## Потокобезопасный объект

Пример многопоточности: 1 Java приложение на сайте и много пользователей, которые хотят с ним работать.

Способы потокобезопасности:

1. Не создавать общих ресурсов, создаём только локальные переменные и не передаём их потокам. Если не передавать в поток, то ссылка хранится в стековой области памяти одного потока main и никто не может обратиться к одной и той же области памяти, где хранится объект по этой ссылке. Только один поток => потокобезопасность.
2. Создавать классы без полей. Методы потокобезопасны так как они не используют поля классов (кроме статических констант).
3. Неизменяемость объекта. Создаём класс, объекты которого immitable, т.е. при всех операциях создаётся новый объект.
4. Создавать только Read-only методы, но следить, чтобы не возвращались mutable поля. Чтобы сделать объект immutable нужно чем-то пожертвовать (памятью или быстродействием).
5. Всегда использовать все методы синхронизированными (synchronized, java.utilCuncurrent, synchronized-блок).

## Методы wait(), notify(), notifyAll()

Эти методы есть у **Object**, а значит и у всех объектов в Java.

Отличие метода wait() от метода sleep() в том, что он вызывается у объекта, чей монитор мы захватили.

Метод wait() нужно вызывать внутри synchronized-блока, иначе возникнет exception.

wait(0L) то же самое, что и wait(). При вызове метода wait() поток не всегда будет ждать бесконечно вызова методов notify() или notifyAll(). Но практически во всех случаях будет ждать бесконечно.

При вызове метода wait() состояние потока waiting, при wait(2L) - timewaiting.

Метод notify() уведомит поток, в котором был вызван метод wait().
notifyAll() уведомит все потоки, которые ожидают освобождения объекта.

Метод wait() нужен для того, чтобы поток, вызвавший его у объекта ждал как минимум заданное время, либо бесконечность в случае 0L, пока мы вновь не сможем захватить монитор объекта у которого вызван wait().
wait() освобождает монитор.

wait(), notify(), notifyAll() можно вызвать только у объектов, монитор которых мы захватили.

## Deadlock.

В блок synchronized можно передать только один объект.

```java
public class Account {
    
    private static int generator = 1;
    private int id;
    private int money;

    public Account(int money) {
        this.id = generator++;
        this.money = money;
    }
    
    public void add(int money) {
        this.money += money;
    }
    
    public boolean takeOff(int money) {
        if (this.money >= money) {
            this.money -= money;
            return true;
        }
        return false;
    }

    @Override
    public String toString() {
        return "Account{" +
                "id=" + id +
                ", money=" + money +
                '}';
    }
}

public class AccountThread extends Thread{

    private final Account accountFrom;
    private final Account accountTo;

    public AccountThread(Account accountFrom, Account accountTo) {
        this.accountFrom = accountFrom;
        this.accountTo = accountTo;
    }

    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            synchronized (accountFrom){
                synchronized (accountTo) {
                    if (accountFrom.takeOff(10)) {
                        accountTo.add(10);
                    }
                }
            }
        }
    }
}

public class AccountDemo {
    public static void main(String[] args) throws InterruptedException {
        Account account1 = new Account(20000);
        Account account2 = new Account(20000);
        
        AccountThread accountThread1 = new AccountThread(account1, account2);
        AccountThread accountThread2 = new AccountThread(account2, account1);
        
        accountThread1.start();
        accountThread2.start();

        accountThread1.join();
        accountThread2.join();

        System.out.println(account1);
        System.out.println(account2);
    }
}

```
Может возникнуть ситуация, что accountThread1 захватит монитор объекта account1, а accountThread2 захватит монитор account2, при этом accountThread1 будет ждать освобождения account2, а accountThread2 - account1.
Возникает deadlock.

## Пакет java.util.cuncurrent.

Появился в Java 1.5, условно можно выделить следующие блоки:

* **atomic** - классы с помощью которых можно безопасно работать в многопоточной среде с Integer, Boolean, Long, ссылками
* **locks** - до этого мы использовали synchronized, locks пердоставляет более удобный API для работы с блокировкой мониторов объектов.
* потокобезопасные коллекции
* пулы потоков **ExecutorService**, позволяет экономить время на создание потоков, передаём эти задачи на выполнение пулу.
* вспомогательные классы: **CountDownLatch, CycleBarier, Exchanger, Phaser, Semaphore**

Почти все эти классы не рабтают напрямую с **synchronized** блоками/методами **wait(), notify(), notifyAll()**.

Есть класс **Unsafe**, позволяющий не блокировать напрямую мониторы объектов, чтобы безопасно работать с многопоточностью, при этом есть прирост в производительности.

## Atomic

**AtomicInteger** - потокобезопасная обёртка над типом **int**.
В качестве методов доступны все операции с **int**.

Внутри методов **Аtomic** операции осуществляются с помощью константы **Unsafe U**. Объект класса **Unsafe** не используют каких-либо синхронизаторов, работают непосредственно с памятью на очень низком уровне.

Самим создавать объекты класса **Unsafe** не рекомендуется, это может делать JDK или фреймворки.

У объектов класса **Unsafe** доступны различные методы:
**addressSize** - получить размер по конретному адресу
**allocateInstance(Class <?> cls)** - создать инстанс класса, похоже на **Reflection API**.

Через объекты класса **Unsafe** можно напрямую работать с памятью программы. Так как если бы программировали на языке C++.

Через объекты класса **Unsafe** можно получать все поля классов, даже **private**.

внутри **Unsafe** используются **native методы** - написанные на языке C для ускорения работы. 

Алгоритм использует низкоуровневые машинные инструкции, такие как сравнение и замена (CAS, compare-and-swap, что обеспечивает целостность данных и по ним уже существует большое количество исследований).

Типичная операция CAS работает с тремя операндами:

* Место в памяти для работы (M)
* Существующее ожидаемое значение (A) переменной
* Новое значение (B), которое необходимо установить

CAS атомарно обновляет M до B, но только если значение M совпадает с A, в противном случае никаких действий предприниматься не будет.

В первом и втором случае вернут значение М. Это позволяет объединить три шага, а именно — получение значения, сравнение значения и его обновление. И это все превращается в одну операцию на машинном уровне.

В тот момент времени, когда многопоточное приложение обращается к переменной и пытается обновить его и применяется CAS, то один из потоков получит его и сможет обновить его. Но в отличии от блокировок, другие потоки просто получат ошибки о том, что им не удалось обновить значение. Потом они перейдут к дальнейшей работе, а переключение полностью исключено при таком типе работе.

При этом логика становится труднее из-за того, что мы должны обработать ситуацию, когда операция CAS не отработала успешно. Мы просто смоделируем код таким образом, чтобы он не двигался дальше, пока операция не произойдет успешно.

В среднем CAS работает быстрее, чем synchronized блоки.

AtomicReferenсe часто используется при работе с коллекциями, когда мы хотим узнать, установилось ли какое-либо значение в нашу коллекцию.

## Lock

Lock - замена synchronized методам и блокам. Выделяется отдельный класс, по сути используют поле в каждом из объектов, которое имеет тип Lock. Обязанность за lock монитора нашего объекта выносится в стороннее поле. 
Будет блокироваться не монитор объекта, а монитор lockа.
Все операции проходят через объекты Unsafe, то есть на очень низком уровне.

Добавим в класс Account поле Lock 

```java
public class Account {
    
    private static int generator = 1;
	private final Lock lock = new ReentrantLock();
    private int id;
    private int money;
	...
}


public class AccountThread extends Thread{

    private final Account accountFrom;
    private final Account accountTo;

    public AccountThread(Account accountFrom, Account accountTo) {
        this.accountFrom = accountFrom;
        this.accountTo = accountTo;
    }

    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            lockAccounts();
			try {
            	if (accountFrom.takeOff(10)) {
                	accountTo.add(10);
          		}
			} finally {
				accountFrom.getLock().unlock();
				accountTo.getLock().unlock();
			}
        }
    }

	private void lockAccounts(){
		while(true) {
			boolean fromLockResult = accountFrom.getLock().tryLock();
			boolean toLockResult = accountTo.getLock().tryLock();
			if (fromLockResult && toLockResult) {
				break;
			}
			if (fromLockResult) {
				accountFrom.getLock().unlock();
			}
			if (toLockResult) {
				accountTo.getLock().unlock();
			}	
		}	
	}
}
```
Метод unlock() можно вызвать только у объекта у которого захвачен монитор, иначе будет exception.

В случае возникновения ошибок в методах takeOff и add мы можем не отпустить мониторы наших локов, поэтому в блоке finally необходимо отпустить мониторы.

Таким образом если необходимо захватить монитор у объекта, лучше захватить его у объекта класса Lock.

ReentrantReadWriteLock - ещё одна часто используемая реализация Lock(). Используется в тех случаях, когда нужно читать из многих потоков, а записывать из одного.

## Thread pool

Thread pool - множество объектов типа Thread, которые можно использовать для решения различных задач.

Создание потока - трудозатратная операция по времени.

Метод run() у потока вызывается автоматически, как только поток был создан JVM.

Таким образом можно один раз создать несколько потоков и по мере их освобождения поручать им решение различных задач.

```java
public class PoolThread extends Thread{
    
    private final Queue<Runnable> tasks;

    public PoolThread(Queue<Runnable> tasks) {
        this.tasks = tasks;
    }

    @Override
    public void run() {
        while(true) {
            Optional<Runnable> task = Optional.empty();
            synchronized (tasks) {
                if (!task.isEmpty()) {
                    task = Optional.of(tasks.remove());
                }
            }
            task.ifPresent(Runnable::run);
        }
    }
}
```

Для создание ThreadPool есть утилитный класс - Executors.

```java
public class ThreadPoolDemo {

    public static void main(String[] args) {
        
        // создаётся один поток
        Executors.newSingleThreadExecutor();

        // pool из 5 потоков
        Executors.newFixedThreadPool(5);

        // безграничный метод, сколько задач отправили, столько будет потоков
        // при этом если в следующий раз передаётся меньше потоков, то новые не будут созданы
        // если больше, то создадутся новые.
        Executors.newCachedThreadPool();

        // выполнение задач с задержкой по времени
        Executors.newScheduledThreadPool(3);

        // создаёт thread pool на основании другой реализации thread pool
        // ForlJoinPool - создаёт пулл оптимального размера, исходя из колличества
        // свободных процессоров, можем не задумываться о колличестве потоков
        Executors.newWorkStealingPool();

    }
}
```

Интерфейс Callable появился с пакетом java.util.cuncurrent отличается от Runnable тем, что возвращает результат и пробрасывает исключение.

threadPool создается следующим образом:

```java
ExecutorService threadPool = Executors.newFixedThreadPool(5);

```

threadPool обычно является полем у объекта, либо статическим полем у класса.

Потоки в threadPool нужно закрывать методом shutdown().

Методы threadPool:

* submit() передаем задачу, нужен результат 

* execute() - передаём задачу, результат не нужен. 

* shutdown() - дождаться завершения всех задач.

* shutdownNow() - возвращает List<Runnable> лист незавершенных задач.

* awaitTermination(long timeout, TimeUnit unit) - сколько нужно ожидать при shutdown().

* invokeAll() - передаем сразу коллекцию задач, и получаем лист Future. Ограничение - все задачи должны быть параметризованы одним и тем же типом.

Future - объект с результатом выполнения задачи в будущем. Позволяет выполнять задачи, не блокируя основной поток.

get() - получить значение Future. До вызова get() никакой поток не блокируется.

Основная реализация Future - CompletableFuture.

Если не передаем в CompletableFuture ThreadPool, то вызывается ASYNC_POOL - дефолтный threadPool, статическое поле.

Методы newScheduledThreadPool():

* schedule(Runnable command, long delay, TimeUnit unit) - задаём ещё и задержку по времени, после которой начинается выполение задачи.

* scheduleAtFixedRate() - задаётся время задержки и переодичность выполнения. shutdown() делать не нужно, потому, что это задача у будущем.

## Потокобезопасные коллекции

Все коллекции имеют свои потокобезопасные аналоги из пакета java.util.cuncurrent.

Аналог Set - CopyOnWriteArraySet. Имеет одно поле CopyOnWriteArrayList\<E> al.

CopyOnWriteArrayList работает таким образом, что при считывании данных (read) не блокирует потоки. 
При записи создаётся копия листа и потоки блокируются. Но при этом чтение выполняется из копии, пока исходный
лист не будет окончательно заменён.

CopyOnWriteArrayList следует использовать тогда, когда много операций на чтение и мало на запись. В противном случае 
будет overhead по памяти, т.к. при каждой операции записи создаётся массив-копия.

## Семафоры

Самое простое средство контроля за тем, сколько потоков могут одновременно работать — семафор. Как на железной дороге. Горит зелёный — можно. Горит красный — ждём. Что мы ждём от семафора? Разрешения. Разрешение на английском — permit. Чтобы получить разрешение — его нужно получить, что на английском будет acquire. А когда разрешение больше не нужно мы его должны отдать, то есть освободить его или избавится от него, что на английском будет release. Посмотрим, как это работает.

```java
public static void main(String[] args) throws InterruptedException {
	Semaphore semaphore = new Semaphore(0);
	Runnable task = () -> {
		try {
			semaphore.acquire();
			System.out.println("Finished");
			semaphore.release();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	};
	new Thread(task).start();
	Thread.sleep(5000);
	semaphore.release(1);
}
```

Как видим, запомнив английские слова, мы понимаем, как работает семафор. Интересно, что главное условие — на "счету" семафора должен быть положительное количество permit'ов. Поэтому, инициировать его можно и с минусом. И запрашивать (acquire) можно больше, чем 1.

При вызове acquire() если в семафоре есть permits, то происходит инкремент и поток пропускается дальше, если нет - то ожидает. При release() permits возвращается обратно в семафор.

При создании объекта Semaphore задаётся как раз число permits.

## CountDownLatch.

Это похоже на бега или гонки, когда все собираются у стартовой линии и когда все готовы — дают разрешение, и все одновременно стартуют. Пример:

```java
public static void main(String[] args) {
	CountDownLatch countDownLatch = new CountDownLatch(3);
	Runnable task = () -> {
		try {
			countDownLatch.countDown();
			System.out.println("Countdown: " + countDownLatch.getCount());
			countDownLatch.await();
			System.out.println("Finished");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	};
	for (int i = 0; i < 3; i++) {
		new Thread(task).start();
 	}
}
```

await на английском — ожидать. То есть мы сначала говорим countDown. Как говорит гугл переводчик, count down — "an act of counting numerals in reverse order to zero", то есть выполнить действие по обратному отсчёту, цель которого — досчитать до нуля. А дальше говорим await — то есть ожидать, пока значение счётчика не станет ноль.

Интересно, что такой счётчик — одноразовый. Как сказано в JavaDoc — "When threads must repeatedly count down in this way, instead use a CyclicBarrier", то есть если нужен многоразовый счёт — надо использовать другой вариант, который называется CyclicBarrier.

## CyclicBarier.

```java
public static void main(String[] args) throws InterruptedException {
	Runnable action = () -> System.out.println("На старт!");
	CyclicBarrier berrier = new CyclicBarrier(3, action);
	Runnable task = () -> {
		try {
			berrier.await();
			System.out.println("Finished");
		} catch (BrokenBarrierException | InterruptedException e) {
			e.printStackTrace();
		}
	};
	System.out.println("Limit: " + berrier.getParties());
	for (int i = 0; i < 3; i++) {
		new Thread(task).start();
	}
}
```

Как видим, поток выполняет await, то есть ожидает. При этом уменьшается значение барьера. Барьер считается сломанным (berrier.isBroken()), когда отсчёт дошёл до нуля.

Чтобы сбросить барьер, нужно вызвать berrier.reset(), чего не хватало в CountDownLatch.

## Exchanger

Следующее средство — Exchanger. Exchange с английского переводится как обмен или обмениваться. А Exchanger — обменник, то есть то, через что обмениваются. Посмотрим на простейший пример:
```java
public static void main(String[] args) {
	Exchanger<String> exchanger = new Exchanger<>();
	Runnable task = () -> {
		try {
			Thread thread = Thread.currentThread();
			String withThreadName = exchanger.exchange(thread.getName());
			System.out.println(thread.getName() + " обменялся с " + withThreadName);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	};
	new Thread(task).start();
	new Thread(task).start();
}
```
Тут мы запускаем два потока. Каждый из них выполняет метод exchange и ожидает, когда другой поток так жевыполнит метод exchange. Таким образом, потоки обменяются между собой переданными аргументами.

Интересная штука. Ничего ли она вам не напоминает?

А напоминает он SynchronousQueue, которая лежит в основе cachedThreadPool'а.

## Phaser

Phaser вполне естественно расширяет функциональность предшественника из JDK 1.5, CyclicBarrier (про него можно почитать тут):
* Количество участников барьера может меняться.
* Поток не обязан ожидать, пока все участники соберутся на барьере. Достаточно только сообщить о готовности своей работы.
* Наоборот, потоку необязательно быть участником барьера, чтобы ожидать его преодоления.

Кстати, это расширение настолько общо, что согласуется и с контрактом третьего барьера из стандартной библиотеки, CountDownLatch.

Состояние этапщика включает
- номер этапа (фазы, цикла синхронизации) | int phase
- количество участников | int parties
- количество участников, которые заявили/не заявили о своей готовности | int arrived, unarrived
- состояние завершения | boolean terminated

0.Если этапщик находится в терминальном состоянии (terminated = true), он не изменяем; вызов любого управляющего метода возвращает немедленно. Phase имеет отрицательное значение, parties, arrived, unarrived — значение в момент завершения.

 
1.Основные управляющие методы:
- register()	зарегистрировать участника
- arrive()	сообщить этапщику о своей готовности, не ожидая открытия барьера
- arriveAndAwaitAdvance()	классическое прибытие на барьер. Точный аналог CyclicBarrier.await()
- arriveAndDeregister()	отменить свое участие

Ясное дело, как и в других синхронизаторах из JDK, вызывающий поток в управляющих методах не отслеживается, поэтому термины вроде «потока-участника» и «своей регистрации» условны. Т. е. заряженный пистолет уже у нас в руках, осталось направить его на ногу и спустить курок :-) Впрочем, несложно написать обертку, исправляющую эту опасную ситуацию.
 
2.Барьер открывается сразу после всякого уменьшения unarrived до нуля.1 То есть, в том числе, когда снимается последний участник, однако при создании «пустого» этапщика (new Phaser() или new Phaser(0)) «ворота закрыты».

Так или иначе, преодолеть барьер можно только с вызовом одного из методов, начинающихся на «arrive». В контексте потока, который это сделает, выполняется protected-метод onAdvance(phase, parties) — если он возвращает true, этапщик завершает свою работу (terminated ← true). Этот механизм позволяет управлять жизненным циклом изнутри класса. В дефолтной реализации phaser умирает как раз если с барьера ушли все участники (parties = 0).

Открытие барьера есть переход на новый этап: phase ← phase + 1.

```java
public static void main(String[] args) throws InterruptedException {
        Phaser phaser = new Phaser();
        // Вызывая метод register, мы регистрируем текущий поток (main) как участника
        phaser.register();
        System.out.println("Phasecount is " + phaser.getPhase());
        testPhaser(phaser);
        testPhaser(phaser);
        testPhaser(phaser);
        // Через 3 секунды прибываем к барьеру и снимаемся регистрацию. Кол-во прибывших = кол-во регистраций = пуск
        Thread.sleep(3000);
        phaser.arriveAndDeregister();
        System.out.println("Phasecount is " + phaser.getPhase());
    }

    private static void testPhaser(final Phaser phaser) {
        // Говорим, что будет +1 участник на Phaser
        phaser.register();
        // Запускаем новый поток
        new Thread(() -> {
            String name = Thread.currentThread().getName();
            System.out.println(name + " arrived");
            phaser.arriveAndAwaitAdvance(); //threads register arrival to the phaser.
            System.out.println(name + " after passing barrier");
        }).start();
    }
```
Из примера видно, что барьер при использовании Phaser'а прорывается, когда количество регистраций совпадает с количеством прибывших к барьеру.

ThreadLocal<T> переменная, которая хранит значение для каждого потока. Основана на map (имя потока, значение переменной)

## Регулярные выражения.

^ - начало проверяемой строки<br>
$ - конец проверяемой строки<br>
. - любой символ<br>
\\\d - цифровой символ<br>
\\\D - не цифровой символ<br>
\\\s - пробельный символ<br>
\\\S - не пробельный символ<br>
\\\w - буквенный, цифровой или подчёркивание<br>
\\\W - любой, кроме буквенного, цифрового или подчёркивания<br>

Квантификаторы:

\+ - одно или более<br>
\* - ноль или более<br>
? - ноль или одно<br>
{n} - ровно n раз<br>
{m, n} - от m до n включительно<br>
{m,} - не менее m<br>
{,n} - не более n<br>

^(1|2|3)$ - мета-символ или. 1 или 2 или 3

() - группы <br>
"(//d{3})(a-z{4})//2" - // ссылка на группу 2 (a-z{4}), в данном выражении.

[Nn], [a-zA-Z0-9] - символьные классы

[^089] - исключающий символ, всё кроме 8,9,0.

```java
Pattern pattern = Pattern.compile("\\d{3}");
Matcher matcher = pattern.matcher("123");
System.out.Println(matcher.match) // true

Pattern.matches(regex, str) // более короткая запись
str.matches(regex) // ещё один вариант
```

##Find()

У объекта matcher в цикле while можно вызвать метод find() и пройти по всем совпадениям по регулярному выражению.

```java
String regex = "(\\+7)(?<code>\\d{4})"
while (matcher.find()) {
    System.out.println(matcher.group());
     System.out.println(matcher.group(0)); // аналог вызова метода group() без параметров
    System.out.println(matcher.group("code")); // к группе можно обрабиться по имени
}
```

(?://d) - исключить группу из списка групп регулярного выражения.

## Замена подстрок

```java
String phoneNumber = ...
String regex = ...
String replaceExpression
Pattern pattern = Pattern.compile(regex);
Matcher matcher = pattern.matcher(phoneNumber);
StringBuilder stringBuilder = mew StringBuilder();
while (matcher.find()) {
    matcher.appendReplacement(stringBuilder, replaceExpression); // Заменить подходящую подстроку на replaceExpression

    //matcher.appendReplacement(stringBuilder, "$2"); - ссылка на 2 группу.
}
matcher.appendTail(stringBuilder); // без этого остаток строки после послднего найденного вхождения regex будет потерян.

System.out.println(stringBuilder);
System.out.println(phoneNumber.replaceAll(regex, "$2"));
```

Квантификатор + - жадный, чтобы он был ленивым нужно поставить знак ?.

## Reflection API

Благодаря использованию класса class мы можем напрямую работать с созданными нами классами. Получать имя класса, конструкторы, названия методов, возвращаемые значения, модификаторы доступа, названия переменных и так далее.

Используется в Spring, Hibernate.

Достучаться до класса можно двумя способами

```java
Class<? extends User> userClass = user.getClass();
Class<User> userClass1 = User.class;
```
userClass == userClass1 и они синглтоны.

getDeclaredFields() - получить поля класса.

getSuperclass() - получаем доступ к супер-классу класа. Так можно дойти до класса Object.

getMethods() - получить все методы.

getDeclaredMEthod() - получить только методы класса.

getInterfaces() - получить все реализованные интерфейсы.

getActualTypeArguments() - можем узнать чем параметризован дженерик.

getClassLoader() - каждый класс знает свой ClassLoader, который загружает класс в JVM при первом обнаружении.












