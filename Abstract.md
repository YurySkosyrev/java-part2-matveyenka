# Курс по Java. Part 2 #
## ООП ##

В Java никакой класс не должен лежать в root-директории src. Нужно создавать пакеты.

Live-template - пишем ключевое слово и нажимаем Tab (или Enter). Idea сама генерирует нужный код.
Ex. iter - цикл for-each. main, sout e.t.c

Структурное программирование - последовательное выполнение кода, строчка за строчкой.

ООП - стиль программирования, в котором операции производятся над объектами, используется их функционал и изменяется их состояние.

Объект - конкретный экземпляр кого-либо класса.

Классы согласно конвенции именуются с большой буквы в camel-case, методы с маленькой буквы. Исключение - конструктор, его имя должно совпадать с именем класса и начинаться с большой буквы.

Ctrl + D - продублировать выделенный код.

В сигнатуру метода входит название функции и аргументы. Возвращаемый тип не входит в сигнатуру метода, он не учитывается при перегрузке.

Ctrl + P - показывает все возможные перегрузки метода.

Модификаторы доступа ставятся над классами, полями, методами.

package private (нет модификатора) - доступ только внутри пакета.

protected - похож на package-private, только ещё доступ предоставляется в классах-наследниках.

Для классов, кроме внутренних вложенных можно указывать либо public, либо ничего.

Пакет - неотъемлимая часть имени класса.

Пакет java.lang импортится автоматически.

## Heap and Stack

При начале работы Java-приложения ему выделяется некоторое колличество оперативной памяти, необходимой для работы. Размер памяти определяется через параметры командной строки или дефолтным значением.

Память, которая выделяется под Java-процесс разбивается на два блока: самый большой - Heap и Stack.

Heap - общий для всех потоков, а Stack создаётся для каждого потока свой.

В многопоточности возникают коллизии, когда из разных Stackов происходит доступ к одному и тому же объекту в Heap.

Правила:
1. Во время выполнение программ все локальные переменные примитивного типа (и их значения) полностью находятся в стековой области памяти. 
2. Ключевое слово new означает выделение памяти под объект в Heap. В Stack хранится ссылка на эту область памяти.

В Java по умолчанию под ссылки выделяется 4 байта. Размер зависит от размера Heap, если он больше 32 ГБ, то на ссылку выделяется 8 байт, чтобы покрыть адресное пространство.

У каждого объекта есть ссылка this, которая указывает на этот объект, для удобства.

После выполнения потока все ссылки на объекты в Heap удаляются. И необходимо собрать мусор с помощью Garbage Collector. В Heap есть разные области памяти, чтобы разделять новые и старые объекты и запускать разные механизмы для очистки Heap.

Ctrl + Alt + M - участок кода переносится в отдельный метод.

По статистике строки занимают до 70% объема Heap, поэтому придуманы различные методы обратки строк. 
Например, кэширование, то есть, если строка есть в Heap, её переиспользуют, а не создают объект заново.

Модификатор static указывает, что поле или метод относится ко всему классу, а не к конкретному экземпляру и может быть вызван по имени класса.
Вызвать через ключевое слово this значение этого поля нельзя.

Метод getClass возвращает класс, к которому принадлежит объект.
Class<? extends Computer> clazz = computer.getClass();

класс Class необходим, чтобы инициализировать классы, которые мы создаём. На каждый класс, который мы создали создаётся объект, который сохраняется в MetaSpace - область памяти в Heap для хранения классов.

Static используется для утилитных классов, для которых не нужен конретный экземпляр.

Константы в классах принято создавать статическими.

prsf - создание private static final.

Согласно конвенции все константы должны именоваться в upper-case и snake-case.

## Класс String

В классе String главное поле - byte[] value. В более ранних версиях было char[]. Замена связана с более оптимальным использованием памяти, большинство строк представляют собой массивы латинских символов, один символ занимает 1 байт, а char занимает 2 байта.

По умолчанию Charset - utf-8. Можно передавать Charset в конструктор String.

Строки сравниваются методом compareTo.

lines() - возвращает стрим из строки.

Из static функции мы можем вызывать только static функции, либо статеческие методы у классов.

Ctrl + Alt + V - создание переменной.

Ctrl + Alt + N - убрать локальную переменную (inline).

Все методы класса String создают новую строку, так как объекты класса String immutable.

System - утилитный метод. Содержит только private конструктор, т.е. экземпляр этого класса можно создать только из него самого.

Для конкатенации строк в цикле необходимо использовать StringBuilder. При обычной конкатенации строк каждый раз создаётся новый объект.
В классе StringBuilder так же есть массив char[] value, но ещё и счётчик count, который показывает на сколько заполнен массив.
StringBuilder работает похожим образом на ArrayList. Таким образом новый объект создаётся тольк тогда когда заканчивается capacity массива value.

StringBuffer - потокобезопасный класс, то есть все его методы синхронизированы (помечены ключевым словом synchronized - то есть эту функцию у одного и того же объекта может вызвать только один поток одновременно)

Однако часто используется и StringBuilder т.к. мы создаём локальную переменную этого типа, которая потокобезопасна. Потому что каждый поток создаёт свою локальную переменную и только у него есть доступ к ссылке на эту переменную.

## Принципы ООП

Инкупсуляция - скрытие сложности(поля) от пользователя.
public-методы называют интерфейсами.

extends - ключевое слово наследования. При наследовании мы обязаны вызвать в конструкторе, один из конструкторов родителя (super()).
super() вызывается в первой строчке.
Если в классе есть конструктор без параметров, то super() можно опустить.

В Java нет множественного наследования.

В Java все классы наследуются от класса Object.

Ctrl + F12 - отображение всех методов класса.

Через ключевое слово this() можно вызвать конструктор данного класса.

native - ключевое слово, означающее, что данный метод использует нативные библиотеки (напианные на С, С++) для улучшения производительности.

В каждом классе можно указать блок инициализации (используется редко), он выполняется перед конструктором:
 {
    System.out.println("init")
 }

Статический блок инициализации вызывется один раз при создании первого объекта класса, т.е. когда создаётся объект класса Class
 static {
    System.out.println("init")
 }


## Абстрактные классы

+ Запрещается создавать экземпляры класса.
+ Класс создан только для его наследования.

Чтобы сделать класс абстрактным его нужно пометить ключевым словом abstract.

Абстрактный метод - метод, который должен быть переопределен во всех классах наследниках.

Ex. public abstract void load();

Если другой абстрактный класс наследует абстрактный, то нет обязательства реализовывать абстрактный метод.

Мы не можем создать абстрактный метод у неабстрактного класса.

Чтобы запретить наследование от данного класса нужно использовать ключевое слово final. Нельзя одновременно ипользовать ключевые слова final и abstract.

Полиморфизм - один интерфейс и множество реализаций.
Под интерфейсом понимается открытый функционал класса.

Переопределить можно не только абстрактные методы, главное, чтобы они не были private.

Мы не можем сужать область видимости базового функционала.

instanseof - действительно ли ссылка ведёт на объект указанного типа.

Если пометить метод ключевым словом final его нельзя будет переопределить в классах-наследниках.

static методы нельзя переопределить, потому что они относятся не к объекту, а к классу.

Интерфейсы нужны для того, чтобы привнести какой-то функционал в наш класс.
В интерфейсах в отличии от абстрактных классов нельзя создавать никакие поля, кроме констант.
В интерфейсах все методы по умолчанию public abstract.
Интерфейсы так же можно наследовать ключевым словом extends, только в отличии от классов допустимо множественное наследование т.к. это наследование интерфейсов.

Ключевое слово default введно начиная с Java 8. В Java 8 появились stream в коллекциях и было необходимо привнести новый функционал в существующую иерархию коллекций, но без её расширения и введения новых классов. Дефолтные методы не зависят от состояния, а зависят от функционала.

default методы используются тогда, когда реализация какого-то метода во всех классах одинакова. Такие методы реализуются прямо внутри интерфейса.

Так же в Java 8 стало возможным создавать private методы в интерфейсах. Такие методы можно было бы создавать static, но тогда к ним будет доступ и вне, а так как это скрытая реализация их сделали private.

Во вложенных классах помимо модификаторов public и package private допустимо использовать private.

Вложенные классы могут быть static, но тогда у них теряется доступ к методам внешнего класса, к полям, доступ остаётся.

Локальный класс описывается и объявляется внутри метода.

Enum - нужен когда необходимо ограничить число наследников класса.
Константы в enum пишутся в Snake Upper case, по сути это обычные классы.
Доступны методы values(), ordinal() и так далее.
Java автоматически создает singltone констант в enum.
Нельзя наследоваться или наследовать enum.
Но доступна реализация интерфейсов (в том числе абстрактных). Переопределение абстрактных методов происходит прямо в блоке кода после каждого из перечислений. Так же можно и переопределить методы интерфейса либо для каждого класса, либо для всего enum в отдельном методе.

## Generics

Generics - обобщенные типы.

В Java запрещено создавать массивы параметризованного типа, т.к. неизвестно, сколько выделить под него памяти.

При объявлении класса, даже если он параметризован, Java допускает не указвать тип класса для совместимости с предыдущими версиями. При этом класс параметризуется типом Object.

Generics нужны для безопасной работы с типами объектов.

Есть два уровня параметризации - на уровне класса и на уровне метода.

public abstract class Hero\<T> {...}

public class Archer\<T> extends Hero\<T> {...}

Параметризацию так же можно ограничивать: 

public interface Weapon {...}<br>
public interface RangeWeapon extends Weapon {...}<br>
public class Bow inplements RangeWeapon {...}

public abstract class Hero\<T extends Weapon> {...}

public class Archer\<T extends RangeWeapon> extends Hero\<T> {...}
Archer\<Bow> archer = new Archer<>();

каждый класс может быть параметризован несколькими типами

Параметризация на уровне метода:
public static \<T extends Weapon> void printWeaponDamage(Hero\<T> hero) {...}

Можно использовать wildcard:
public static void printWeaponDamage(Hero\<? extends Weapon> hero) {...}

Можно ограничивать наследование снизу т.е. для всех предшественников:
public static void printWeaponDamage(Hero\<? super Weapon> hero) {...}

Ограничения сверху и снизу используются для 
* Producer - extends
* Consumer - super

## Коллекции

Коллекция - структура данных, набор элементов одного и того же типа.

interface Collection/<E> extends Iterable/<E>- базовый интерфейс, все коллекции реализуют этот интерфейс.

Итератор - шаблон проектирования, который позволяет нам итерировать по всем элементам коллекции.

Коллекции нельзя параметризовать примитивным типом, именно для этого существуют классы обёртки.

Основные интерфейсы коллекций:
* List
* Set
* Queue

Map не является коллекцией, но содержит коллекцию

## Big O Notation

O(1) - получить элемент по индексу из массива

O(log2 n) - бинарный поиск

O(n) - вставка в массив

O(n logn) - хорошая сортировка

O(n^2) - сортировка пузырьком

O(2^n) - 

O(n!) - самая плохая 

При создании массива с помощью слова new мы получаем ссылку на первый элемент массива в Heap. Чтобы получить элемент по индексу (например, если элементы типа int) нужно взять адрес первого элемента и сместить его на 4 * i байт.

Big O Notation используется не только для оценки скорости выполнения алгоритма, но и для оценки выделения объёма памяти. 

## ArrayList

List.of() - создание неизменяемого списка на основе элементов.

transient Odject[] elementData - главное поле класса ArrayList. По сути ArrayList - список в основании которого обычный массив.

Если колличество элементов превышает capaсity, то массив автоматически расширяется, новая capacity считается по определенному алгоритму в методе grow(). Создаётся новый массив с новым размером, в который копируется старый.

При инициализации ArrayList создаётся elementData с дефолтным значением (пустым) DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} по сути это заглушка.

Сложность:
Добавление элемента (по скорости) - O(1)
Добавление элемента (по памяти) - O(n)
Получение элемента по индексу - O(1)
Получение элемента по значению - O(n)

## LinkedList

Реализация интерфейса List не основывающаяся на массиве.

LinkedList хранит указатели на первый и последний элемент типа Node<E>, а так же колличество элементов.
Node<E> оболочка над значением Е, которая хранит ссылка на предыдущий и следующий узел.

Хранение не только элементов, но и ссылок на другие элементы означает, что памяти требуется больше чем у ArrayList.

LinkedList реализует интерфейс Deque.

Сложность:
Добавление элемента (по скорости) - O(n)
Добавление элемента (по памяти) - O(1)
Получение элемента по индексу - O(n)
Получение элемента по значению - O(n)

При поиске по индексу есть определенная оптимизация - определяется откуда ближе идти, с конца или с начала.

Если много вставок и удаление в середину, то есть определённая выгода LinkedList.

## Iterator

Два основных метода hasNext() и next(). Перед вызовом next() нужно вызывать hasNext().

Через цикл foreach удалить элементы не получится, foreach только на чтение.

## Equals and HashCode

Все объекты наследуются от Object, поэтому им доступны методы equals() и hashCode(). hashCode() написан на языке C (помечен native), он генерирует некое число int на основании области памяти, выделенной для нашего объекта.

Методы equals() и hashCode() необходимо переопределять одновременно.

Контракты метода equals():

1. Рефлексивность. Объект должен быть равен самому себе, т.е. для каждого ненулевого х, x.equals(x) должно возвращать true.

2. Симметричность. Объекты должны быть равны друг другу, т.е. для ненулевых х и y x.equals(y) должно возвращать true только если y.equals(x) возвращает true

3. Транзитивность. Для ненулевых x, y, z если x.equals(y) == true, y.equals(z) == true => x.equals(z) == true.

4. Повторяемость. Для ненулевых x и y последовательные вызовы x.equals(y) должны постоянно возвращать true или постоянно возвращать false, при условии, что x и y не меняются.

Особенности HashCode()

1. У двух одинаковых обектов ДОЛЖЕН быть одинаковых хеш-код

2. У двух разных объектов МОЖЕТ быть одинаковый хеш-код. Это называется коллизией. Особенность хорошо написанной функции hashCode() - минимум коллизий.

3. Нельзя возвращать константу или рандомное число.

Object - утилитный класс, появился после Java 1.7, содержит методы для работы с классами.

## HashMap

Ассоциативный массив содержит в себе два generic типа - ключ и значение.

Главное требование - уникальность ключа.

Ассоциативный массив в Java представлен реализациями интерфейса Map<K, V>
HashMap() - Map на основе hash-таблиц.

Map не является коллекцией, но содержит в себе две коллекции:
* keySet(): Set<K>
* values(): Collection<V>

Основное поле Map - transient Node<K,V>[] table
Node состоит из полей
final int hash - хеш-код ключа, подсчитывается один раз и сохраняется
final K key - ключ
V value - значение
Node<K,V> next - ссылка для решения коллизий.

Все размеры ассоциативных таблиц кратны 2 в некоторой степени.
Начальный размер массива - 16.

При помещении объекта в HashMap на основании ключа вычисляется его хеш-код. Берём остаток от деления на количество элементов в массиве Map (бакетов) и определяем ячеку, в которую необходимо поместить новый объект типа Node<K,V>.

В случае, если хеш-код у нового объекта совпадает с ранее записанным, то всё равно создаётся объект Node<K,V>, на который будет ссылаться ссылкасNode<K,V> next последнего объека в листе в бакете.

Начиная с Java 1.8 если в одной ячейки становится много (больше 8), то связанный список преобразуется в дерево.
Сложно итерации по списку O(n) по дереву O(logN), что лучше.

При получении элемента по ключу, если попадём в бакет с несколькими элементами, то будем итерировать по списку и сравнивать ключи. Т.к. главное условие Map - уникальность ключа, то будет найдет только один объект. 
А при добавлении объекта с таким же ключем, предыдущее значение будет перезаписано

Преимущество HashMap в том, что доступ к элементу осуществляется за время O(1).

Node<K, V> реализует интерфейс EntrySet<K, V>

putIfAbcent - добавить в Map только в том случае, если такого ключа не существует.

Расширение массива происходит, когда достиается loadfactor.
Т.е. процент заполненности.

## LinkedHashMap

При добавлении элементов в HashMap порядок добавления элементов нарушается потому, что порядок зависит от хеш-кода ключа.

Чтобы сохранить порядок используем LinkedHashMap.

LinkedHashMap - это обычный HashMap, который хранит в классе Entry<K, V> extends Node<K, V> ссылки на предыдущий и последующий элемент.

## Сортировка коллекций

Метод Array.asList возвращает изменяемую коллекцию.

Чтобы сравнивать объекты необходимо, что бы они реализовывали интерфейс Comparable/<T>, который состоит из одного метода compareTo. Сортируте только в одном порядке.

Тогда с помощью метода Collections.sort(list) можно отсортировать коллекцию.

Так же есть вариант реализовать интерфейс Comparator/<T> и его метод compare(o1:T, o2:T):int.

Позже у класса List появился метод sort, который также принимает компаратор.
myList.sort(new myComparator())

Начиная с Java 1.8 появилась ещё более короткая запись:
myList.sort(Comparator.comparing(Person::getFirstName)).thenComparing(Person::getLastName)

## TreeMap

TreeMap хранит элементы в определенном порядке (в отсортированном виде).
TreeMap может принимать Comparator.

TreeMap основана на красно-черных деревьях.
Сложность поиска и вставки элемента O(logN).

Если постоянно добавлять в одну половину дерева, оно может превратиться в связный список.
Поэтому в TreeMap есть булева переменная, которая зависит от нескольких условий и показывает, когда нужно балансировать дерево.

## Set

Метод add() возвращает boolean - удалось ли добавить или нет.

HashSet не сохраняет порядок при добавлении.
LinkedHashSet сохранят порядок при добавлении.
TreeSet сортирует при добавлении.

Соответствующая реализация Set основана на соответствующей реализации Map, при этом операции производятся только с ключами, а в значение всегда записывается один и тот же Dummy-объект PRESENT.

у Set нет метода sort. Для сортировки нужно использовать TreeSet.

## Другие коллекции

IdentityHashMap - ключи сравниваются по ссылкам, а не по значениям. Нет надобности переопределять equals(). При этом ускоряется процесс генерации hash-кода и сравнение объектов.

WeakHashMap - объекты в ассоциативном массиве хранятся не постоянно, а переодически исчезают. Нужна для хранение кэша.

Hashtable - лучше не использовать. Предшественник HashMap. Старые коллекции хороши тем, что все их методы синхронизированы, это означает что этот метод может быть вызыван только из одного потока в один момент времени. 
Начиная с Java 1.5 появился пакет Java.Util.Cuncurrent, лучше использовать его для потокобезопасности - ConcurrentMap.

Vector - предшественник ArrayList.

Stack - вместо него лучше использовать любую реализацию интерфейса Deque - LinkedList, ArrayDeque (коллекция основана на обычном массиве). 

## Коллекции практика.

Arrays.ofList возвращает неизменяемую коллекцию, remove не поддерживается.
Arrays.asList возвращает так же неизменяему коллекцию, но в ней можно переставлять элементы.
Цикл forEach только для чтения. Во время цикла нельзя удалять элементы.

Параметры, которые передаются в метод лучше не менять, нужно создавать новый объект внутри метода и производить с ним действия.

Заполнить Map можно с помощью метода Map.of(K, V)

Начиная с Java 1.8 у Map есть метод merge, которой по ключу и значению выполняет операцию слияние.

Comparator.reverseOrder() - обратный порядок.

## Исключения

Throwable - базовый класс исключений.

Ctrl + Alt + H - открыть иерархию класса.

Throwable:
* Error - ошибки, с которыми ничего нельзя сделать. OutOfMemory - закончилось место в Heap, StackOverFlow - закончилось место в стековой области памяти.

* Exception - можем обработать.
   * Runtime
   * Все остальные

Исключения обрабатываются: 
* в месте, где их бросили : throw new FileNotFoundException()
* либо пробрасываются в метод выше : <br>public static void errMethod() throws FileNotFoundException.

Сообщения об ошибках выводятся в консоль объектом **err**, поэтому при выводе в консоль объектом **out** может возникнуть конфликтная ситуация.

В блоке catch можно обработать несколько исключений с помощью бинарного оператора или |. 

Можно указать общего предка для обработки разных исключений.

При использовании нескольких блоков catch важно учитывать иерархию исключений в этих блоках.

В блоке finally обычно очищаются ресурсы.

finally имеет более высокий приоритет, чем return, если return был вызван в блоке try.

Мы не обязаны остлеживать Runtime исключения т.е. писать try-catch блоки или пробрасывать их дальше с помощью throws. Пробрасывыние происходит автоматически.

RunTimeExceptions можно обрабатывать так же как и неRunTime.
Пример RuntimeException - выход за границы массива, деление на ноль и т.д.

При создании своих Exceptions предпочтительнее наследовать их от RuntimeExceptions

prsf + tab - private static final myVar.

## Функциональное программирование

Функциональный интерфейс содержит единственный метод не default и не private, для реализации.
@FunctionalInterface - предохраняет от объявления второго метода, не default и не private.

Функциональные интерфейсы позволяют использовать лямбда (стрелочные) функции.

Лямбда выражения можно заменить ещё более лаконичной записью с ссылкой на метод Integer::compare.

Функциональные интерфейсы:

public interface Function<T, R>{
   R apply(T t);
}

public interface Predicate<T>{
   boolean test(T t);
}

public interface Consumer<T>{
   void accept(T t);
}

public interface Supplier<T>{
   T get();
}

Ещё BiFunction, BiConsumer.

## Stream

В Java 1.8 появились Stream. Для их введения были так же добавлены default методы в интерфейсах. default метод позволяет не переопределять одинаковым образом у всех коллекций метод stream() интерфейса Collection.

Существуют три отдельных стрима для примитивных типов: IntStream, LongStream, DoubleStream.

peek - нетерминальный метод, forEach - терминальный.

IntStream.range(0,10) - создать стрим в диапазоне от 0 до 10
IntStream.iterate(0, func) - бесконечный стрим.

MapReduce - программная модель, которая позволяет преобразовать данные при необходимости их последующей обработки. Обработка происходит параллельно.

Stream.of(...)
   .parallel()
   .map(Student::getAge)
   .reduce(Math::max)
   .ifPresent(System.out::println)

.sequence - обработка в одном потоке.

## Optional

BinaryOperator /<T, T, T> в отличии от BinaryFunction /<T,V,R> принимает один тип переменной.

Optional - обычная обертка вокруг значения.

Optional всегда работает с одним единственным элементом, в отличии от Stream.

orElse() - всегда создаётся значение и выделяется память под значение по умолчанию (если отсутствует значение в Optional)
orElseGet() - Lazy версия orElse()

flatMap() - приходит Optional и возвращает Optional

Fail-fast метод. Исключение бросается в непосредственном месте появления исключительной ситуации, а не в последующих
методах. Исключительная ситуация находится как можно раньше.

Из методов не принято возвращать null, а Optional.

Optional - nullsafe, isPresent - тоже.

flatmap у Stream возвращает Stream от каждого элемента. Может быть удобно, если у каждого объекта в Stream есть поле типа List.
у Optional нет peek.

Сложность метода sort() у Stream - O(NlogN)
max() - O(N)

Вместо person -> person можно использовать Function.identity().

